<?php

/**
 * Queue Worker
 *
 * Polls the jobs table and dispatches pending jobs.
 *
 * Usage:
 *   php workers/queue_worker.php          # run once
 *   php workers/queue_worker.php --daemon # loop indefinitely (use with Supervisor / systemd)
 *
 * Cron example (run every minute):
 *   * * * * * php /var/www/geoserver/workers/queue_worker.php >> /var/log/queue_worker.log 2>&1
 */

declare(strict_types=1);

require_once __DIR__ . '/../config/database.php';
require_once __DIR__ . '/process_layer.php';

$daemon = in_array('--daemon', $argv ?? [], true);

do {
    processNextBatch();

    if ($daemon) {
        sleep(5);
    }
} while ($daemon);

// ---------------------------------------------------------------------------

/**
 * Pick up pending jobs, mark them running, dispatch them.
 */
function processNextBatch(): void
{
    $pdo = db();

    // Fetch a batch of pending jobs (limit to avoid overwhelming the server)
    $stmt = $pdo->query(
        "SELECT * FROM jobs WHERE status = 'pending' ORDER BY created_at ASC LIMIT 5"
    );
    $jobs = $stmt->fetchAll();

    foreach ($jobs as $job) {
        $jobId = (int)$job['id'];

        // Mark running
        $pdo->prepare("UPDATE jobs SET status = 'running' WHERE id = :id")
            ->execute([':id' => $jobId]);

        try {
            dispatchJob($job);

            $pdo->prepare("UPDATE jobs SET status = 'done' WHERE id = :id")
                ->execute([':id' => $jobId]);

            echo "[" . date('c') . "] Job {$jobId} ({$job['type']}) done\n";
        } catch (Throwable $e) {
            $pdo->prepare("UPDATE jobs SET status = 'error' WHERE id = :id")
                ->execute([':id' => $jobId]);

            fwrite(STDERR, "[" . date('c') . "] Job {$jobId} ({$job['type']}) failed: " . $e->__toString() . "\n");
        }
    }
}

/**
 * Dispatch a single job based on its type.
 */
function dispatchJob(array $job): void
{
    $payload = json_decode($job['payload'], true) ?? [];

    switch ($job['type']) {
        case 'process_layer':
            $layerId = isset($payload['layer_id']) ? (int)$payload['layer_id'] : 0;
            if ($layerId <= 0) {
                throw new RuntimeException("Invalid layer_id in payload");
            }
            processLayer($layerId);
            break;

        case 'build_mbtiles':
            buildMbtilesPackage($payload);
            break;

        default:
            throw new RuntimeException("Unknown job type: {$job['type']}");
    }
}

/**
 * Build an MBTiles package for an offline-package request.
 *
 * Iterates over all tile files already on disk for the given layer,
 * copies them into an SQLite MBTiles database, and updates the
 * offline_packages row when done.
 */
function buildMbtilesPackage(array $payload): void
{
    $packageId = isset($payload['package_id']) ? (int)$payload['package_id'] : 0;
    $layerId   = isset($payload['layer_id'])   ? (int)$payload['layer_id']   : 0;
    $minZoom   = isset($payload['min_zoom'])   ? (int)$payload['min_zoom']   : 0;
    $maxZoom   = isset($payload['max_zoom'])   ? (int)$payload['max_zoom']   : 18;
    $bbox      = trim((string)($payload['bbox'] ?? ''));

    if ($packageId <= 0 || $layerId <= 0) {
        throw new RuntimeException("Invalid package or layer ID");
    }

    $pdo = db();

    // Mark package as processing
    $pdo->prepare("UPDATE offline_packages SET status = 'processing' WHERE id = :id")
        ->execute([':id' => $packageId]);

    $mbtilesDir  = __DIR__ . '/../storage/layers/' . $layerId . '/mbtiles';
    $mbtilesPath = $mbtilesDir . '/package_' . $packageId . '.mbtiles';

    if (!is_dir($mbtilesDir)) {
        mkdir($mbtilesDir, 0755, true);
    }

    // Create the MBTiles SQLite database
    $db = new SQLite3($mbtilesPath);
    $db->exec('PRAGMA journal_mode=WAL');
    $db->exec('CREATE TABLE IF NOT EXISTS metadata (name TEXT, value TEXT)');
    $db->exec('
        CREATE TABLE IF NOT EXISTS tiles (
            zoom_level  INTEGER,
            tile_column INTEGER,
            tile_row    INTEGER,
            tile_data   BLOB,
            PRIMARY KEY (zoom_level, tile_column, tile_row)
        )
    ');

    // Insert metadata
    $metaStmt = $db->prepare('INSERT OR REPLACE INTO metadata (name, value) VALUES (:n, :v)');
    foreach ([
        'name'        => 'offline_layer_' . $layerId,
        'format'      => 'png',
        'bounds'      => $bbox,
        'minzoom'     => (string)$minZoom,
        'maxzoom'     => (string)$maxZoom,
        'type'        => 'overlay',
        'version'     => '1',
        'description' => 'Generated by androMapper',
    ] as $k => $v) {
        $metaStmt->bindValue(':n', $k);
        $metaStmt->bindValue(':v', $v);
        $metaStmt->execute();
    }

    // Parse bbox
    $bboxParts = array_map('floatval', explode(',', $bbox));
    $hasBbox   = count($bboxParts) === 4;

    $tilesDir = __DIR__ . '/../storage/layers/' . $layerId . '/tiles';

    $insertStmt = $db->prepare(
        'INSERT OR REPLACE INTO tiles (zoom_level, tile_column, tile_row, tile_data)
         VALUES (:z, :x, :y, :data)'
    );

    for ($z = $minZoom; $z <= $maxZoom; $z++) {
        $zDir = $tilesDir . '/' . $z;
        if (!is_dir($zDir)) {
            continue;
        }

        foreach (scandir($zDir) as $xEntry) {
            if ($xEntry === '.' || $xEntry === '..') {
                continue;
            }
            $x    = (int)$xEntry;
            $xDir = $zDir . '/' . $xEntry;
            if (!is_dir($xDir)) {
                continue;
            }

            foreach (scandir($xDir) as $yFile) {
                if (!str_ends_with($yFile, '.png')) {
                    continue;
                }
                $y = (int)basename($yFile, '.png');

                // Filter to bbox if provided
                if ($hasBbox && !tileIntersectsBbox($z, $x, $y, $bboxParts)) {
                    continue;
                }

                $tilePath = $xDir . '/' . $yFile;
                $data     = file_get_contents($tilePath);
                if ($data === false) {
                    continue;
                }

                // MBTiles uses TMS y-axis (bottom origin), XYZ is top origin
                $tmsY = (1 << $z) - 1 - $y;

                $insertStmt->bindValue(':z',    $z,    SQLITE3_INTEGER);
                $insertStmt->bindValue(':x',    $x,    SQLITE3_INTEGER);
                $insertStmt->bindValue(':y',    $tmsY, SQLITE3_INTEGER);
                $insertStmt->bindValue(':data', $data, SQLITE3_BLOB);
                $insertStmt->execute();
            }
        }
    }

    $db->close();

    // Update the offline_packages record
    $pdo->prepare(
        "UPDATE offline_packages SET status = 'ready', file_path = :fp WHERE id = :id"
    )->execute([':fp' => $mbtilesPath, ':id' => $packageId]);
}

/**
 * Check whether tile (z, x, y) intersects with a Web Mercator bbox.
 * bbox is [minX, minY, maxX, maxY] in EPSG:3857 metres.
 */
function tileIntersectsBbox(int $z, int $x, int $y, array $bbox): bool
{
    $earthCircumference = 20037508.3427892;
    $n = 1 << $z;

    $tileMinX = ($x / $n) * 2 * $earthCircumference - $earthCircumference;
    $tileMaxX = (($x + 1) / $n) * 2 * $earthCircumference - $earthCircumference;
    $tileMaxY = $earthCircumference - ($y / $n) * 2 * $earthCircumference;
    $tileMinY = $earthCircumference - (($y + 1) / $n) * 2 * $earthCircumference;

    return $tileMinX < $bbox[2]
        && $tileMaxX > $bbox[0]
        && $tileMinY < $bbox[3]
        && $tileMaxY > $bbox[1];
}
